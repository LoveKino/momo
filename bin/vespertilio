#!/usr/bin/env node

const yargs = require('yargs');
const del = require('del');
const path = require('path');
const {deployDpm} = require('../src');
const {
  readConfig, spawnp, existsDir, mkdirp, exec, readJson, writeTxt
} = require('flexdeploy/src/util');

yargs.usage(`Usage: vespertilio
    --upd
    --config    config file path

    --only      only build one worker
    `).help('h').alias('h', 'help');

const {argv} = yargs;

const syncBaseProjects = async(cnf) => {
  if(!await existsDir(cnf.dpm.src) || argv.upd) {
    await del([cnf.dpm.src]);
    await spawnp('git', ['clone', 'git@github.com:lock-free/dpm-cluster-demo.git', cnf.dpm.src]);
    await del([path.join(cnf.dpm.src, '.git')]);
  }

  await Promise.all([
    updateRepo('git@github.com:lock-free/dpm_service.git', cnf.source.repoRoot, 'dpm_service'),
    updateRepo('git@github.com:lock-free/na_service.git', cnf.source.repoRoot, 'na_service'),
    updateRepo('git@github.com:lock-free/httpna_service.git', cnf.source.repoRoot, 'httpna_service')
  ]);
};

const copyDpmData = async (cnf) => {
  // copy dpm cnf
  await copyDir(cnf.dpm.cnfDir, path.join(cnf.dpm.src, './stage/data/cnf'));

  // modify dpm config json on the fly
  await writeTxt(path.join(cnf.dpm.src, './stage/data/config.json'),
    JSON.stringify(
      Object.assign(
        await readJson(cnf.dpm.cnfFile),
        {
          Only: cnf.only || ''
        }
      ),
      null,
      4
    )
  );
};

const copyData = async (cnf) => {
  const srcRepo = path.resolve(cnf.dpm.src, './stage/data/src');

  await Promise.all([
    await copyDpmData(cnf),
    // copy config for httpna
    await copyDir(cnf.httpna.cnfDir, path.join(cnf.dpm.src, './stage/data/src/httpna_service/stage/data')),
  ].concat(
    // copy workers data
    getWorkers(cnf).map(async ({serviceType}) => {
      // copy data dir
      if(cnf.dpm.data) {
        const workerDataSrcDir = path.join(cnf.cwd, cnf.dpm.data, serviceType);
        const workerDataTarDir = path.join(srcRepo, serviceType, './stage/data');
        if(await existsDir(workerDataSrcDir)) {
          await copyDir(workerDataSrcDir, workerDataTarDir);
        }
      }
    })
  ));
};

const getWorkers = (cnf) => {
  return (
    cnf.only? cnf.source.workers.filter(({serviceType}) => serviceType === cnf.only): cnf.source.workers
  );
};

const copyCode = async (cnf) => {
  const srcRepo = path.resolve(cnf.dpm.src, './stage/data/src');

  // copy code to dpm src dir
  await Promise.all([
    await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, 'na_service'),
    await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, 'httpna_service')
  ].concat(
    // copy workers
    getWorkers(cnf).map(async ({serviceType, buildCmd}) => {
      // build first
      if(buildCmd) {
        await exec(buildCmd, {
          cwd: cnf.cwd
        });
      }
      // copy source from repo root to dpm src repo
      await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, serviceType);
    }))
  );
};

// copy projects to dpm source dir
const copyProjects = async (cnf) => {
  await Promise.all([
    await copyCode(cnf),
    await copyData(cnf)
  ]);
};

const deployDpmHelp = async (cnf) => {
  // copy binary
  const dpmBinPath = path.resolve(cnf.dpm.src, './stage/bin/');
  await mkdirp(dpmBinPath);
  await spawnp('cp', [path.resolve(cnf.source.repoRoot, 'dpm_service/stage/bin/dpm_service'), dpmBinPath]);

  // deploy dpm
  await deployDpm(cnf.dpm['deploy-cnf'], 'staging');
};

const getVespertilioConf = async () => {
  const cnfFilePath = path.resolve(process.cwd(), argv.config || 'vespertilio.json');
  const cnf = Object.assign(await readConfig(cnfFilePath), {
    only: argv.only
  });

  const cnfDir = path.dirname(cnfFilePath);

  cnf.cwd = cnfDir;

  // resolve paths
  cnf.source.repoRoot = path.resolve(cnfDir, cnf.source.repoRoot);

  cnf.dpm.cnfDir = path.join(cnfDir, cnf.dpm.cnfDir);
  cnf.dpm.cnfFile = path.join(cnfDir, cnf.dpm.cnfFile);
  cnf.dpm.src = path.resolve(cnfDir, cnf.dpm.src);
  cnf.dpm['deploy-cnf'] = path.resolve(cnfDir, cnf.dpm['deploy-cnf']);
  cnf.httpna.cnfDir = path.join(cnfDir, cnf.httpna.cnfDir);

  return cnf;
};

const run = async () => {
  const cnf = await getVespertilioConf();

  await syncBaseProjects(cnf);
  await copyProjects(cnf);
  await deployDpmHelp(cnf);
};

const updateRepo = async(gitAddr, repoRoot, targetDir) => {
  const repoDir = path.resolve(repoRoot, targetDir);
  if(! await existsDir(repoDir)) {
    await spawnp('git', ['clone', gitAddr, repoDir]);
  } else {
    await spawnp('git', ['pull'], {
      cwd: repoDir
    });
  }
};

// copy stage dir and empty Makefile
const copyStageToDpmSrcRepo = async (repoRoot, srcRepo, targetDir) => {
  const srcStage = path.resolve(srcRepo, targetDir, 'stage');
  const repoStage = path.resolve(repoRoot, targetDir, 'stage');

  await copyDir(repoStage, srcStage);
  await spawnp('cp', [path.join(__dirname, '../res/makefile'), path.resolve(srcRepo, targetDir, 'makefile')]);
};

const copyDir = async (srcDir, tarDir) => {
  await mkdirp(tarDir);
  await del([tarDir]);
  await spawnp('cp', ['-r', srcDir, tarDir]);
};

run();
