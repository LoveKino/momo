#!/usr/bin/env node

const yargs = require('yargs');
const del = require('del');
const path = require('path');
const {deployDpm} = require('../src');
const {
  readConfig, spawnp, existsDir, mkdirp, exec, readJson, writeTxt, existsFile
} = require('flexdeploy/src/util');

yargs.usage(`Usage: vespertilio
    --upd
    --config    config file path

    --only      only build one worker
    `).help('h').alias('h', 'help');

const {argv} = yargs;

const syncBaseProjects = async(cnf) => {
  if(!await existsDir(cnf.dpm.src) || argv.upd) {
    await del([cnf.dpm.src]);
    await spawnp('git', ['clone', 'git@github.com:lock-free/dpm-cluster-demo.git', cnf.dpm.src]);
    await del([path.join(cnf.dpm.src, '.git')]);
  }

  await Promise.all([
    updateRepo('git@github.com:lock-free/dpm_service.git', cnf.source.repoRoot, 'dpm_service'),
    updateRepo('git@github.com:lock-free/na_service.git', cnf.source.repoRoot, 'na_service'),
    updateRepo('git@github.com:lock-free/httpna_service.git', cnf.source.repoRoot, 'httpna_service')
  ]);
};

const copyDpmData = async (cnf) => {
  // copy common dir
  if(await existsDir(path.join(cnf.dpm.cnfDir, 'common'))) {
    await copyDir(path.join(cnf.dpm.cnfDir, 'common'), path.join(cnf.dpm.src, './stage/data/cnf/common'));
  }

  // copy private dir
  await copyDir(path.join(cnf.dpm.cnfDir, 'private'), path.join(cnf.dpm.src, './stage/data/cnf/private'));

  // copy dpm cnf na.json on the fly
  await copyJsonOnTheFly(path.join(cnf.dpm.cnfDir, 'na.json'),
    path.join(cnf.dpm.src, './stage/data/cnf/na.json'),
    {
      'NADeployCnfPath': '/data/cnf/common/na/deploy-cnf.json',
      'NAMachineCnfPath': '/data/cnf/private/machine/na.json',
      NAs: cnf.remote.NAs
    }
  );

  // copy dpm worker.json on the fly
  await copyJsonOnTheFly(path.join(cnf.dpm.cnfDir, 'worker.json'),
    path.join(cnf.dpm.src, './stage/data/cnf/worker.json'),
    {
      'WorkerDeployCnfPath': '/data/cnf/common/worker/deploy-cnf.json',
      'WorkerMachineCnfPath': '/data/cnf/private/machine/worker.json',
      Workers: cnf.remote.worker.Workers,
      Machines: cnf.remote.worker.Machines
    }
  );

  // copy dpm config.json on the fly
  await copyJsonOnTheFly(cnf.dpm.cnfFile,
    path.join(cnf.dpm.src, './stage/data/config.json'),
    // default dpm config.json
    {
      Only: cnf.only || '',
      RemoteRoot: cnf.remote.root,

      'OnlineType': 'staging',
      'NAConfPath': '/data/cnf/na.json',
      'WorkerConfPath': '/data/cnf/worker.json',
      'TargetDir': '/data/target',
      'SrcDir': '/data/src'
    }
  );
};

const copyJsonOnTheFly = async (src, tar, def={}) => {
  await writeTxt(tar,
    JSON.stringify(
      Object.assign(def, (await existsFile(src))? await readJson(src): {}),
      null,
      4
    )
  );
};

const copyData = async (cnf) => {
  const srcRepo = path.resolve(cnf.dpm.src, './stage/data/src');

  await Promise.all([
    await copyDpmData(cnf),
    // copy config for httpna
    await copyDir(cnf.httpna.cnfDir, path.join(cnf.dpm.src, './stage/data/src/httpna_service/stage/data')),
  ].concat(
    // copy workers data
    getWorkers(cnf).map(async ({serviceType}) => {
      // copy data dir
      if(cnf.dpm.data) {
        const workerDataSrcDir = path.join(cnf.cwd, cnf.dpm.data, serviceType);
        const workerDataTarDir = path.join(srcRepo, serviceType, './stage/data');
        if(await existsDir(workerDataSrcDir)) {
          await copyDir(workerDataSrcDir, workerDataTarDir);
        }
      }
    })
  ));
};

const getWorkers = (cnf) => {
  return (
    cnf.only? cnf.source.workers.filter(({serviceType}) => serviceType === cnf.only): cnf.source.workers
  );
};

const copyCode = async (cnf) => {
  const srcRepo = path.resolve(cnf.dpm.src, './stage/data/src');

  // copy code to dpm src dir
  await Promise.all([
    await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, 'na_service'),
    await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, 'httpna_service')
  ].concat(
    // copy workers
    getWorkers(cnf).map(async ({serviceType, buildCmd}) => {
      // build first
      if(buildCmd) {
        await exec(buildCmd, {
          cwd: cnf.cwd
        });
      }
      // copy source from repo root to dpm src repo
      await copyStageToDpmSrcRepo(cnf.source.repoRoot, srcRepo, serviceType);
    }))
  );
};

// copy projects to dpm source dir
const copyProjects = async (cnf) => {
  await Promise.all([
    await copyCode(cnf),
    await copyData(cnf)
  ]);
};

const deployDpmHelp = async (cnf) => {
  // copy binary
  const dpmBinPath = path.resolve(cnf.dpm.src, './stage/bin/');
  await mkdirp(dpmBinPath);
  await spawnp('cp', [path.resolve(cnf.source.repoRoot, 'dpm_service/stage/bin/dpm_service'), dpmBinPath]);

  // copy deploy-cnf.json to dpm dir
  await copyJsonOnTheFly(cnf.dpm['deploy-cnf'],
    cnf.dpm['deploy-cnf'],
    Object.assign({
      'project': cnf.name || 'vespertilio-cluster',

      'srcDir': './src',
      'stageDir': './stage',

      'hooks': {
        'pre': [],
        'afterDeployRemoteCmds': []
      }
    }, cnf.dpm.deploy)
  );

  // deploy dpm
  await deployDpm(cnf.dpm['deploy-cnf'], 'staging');
};

const getVespertilioConf = async () => {
  const cnfFilePath = path.resolve(process.cwd(), argv.config || 'vespertilio.json');
  const cnf = Object.assign(await readConfig(cnfFilePath), {
    only: argv.only
  });

  const cnfDir = path.dirname(cnfFilePath);

  cnf.cwd = cnfDir;

  // merge with default configuration options
  cnf.dpm = Object.assign({
    'deploy-cnf': './dpm/deploy-cnf.json',
    'src': './dpm/src',
    'cnfDir': './conf/dpm/cnf',
    'cnfFile': './conf/dpm/config.json',
    'data': './conf/data'
  }, cnf.dpm || {});
  cnf.httpna = Object.assign({
    'cnfDir': './conf/http_na'
  }, cnf.httpna || {});
  cnf.source = Object.assign({
    'repoRoot': './code_repo',
  }, cnf.source || {});

  // resolve paths
  cnf.source.repoRoot = path.resolve(cnfDir, cnf.source.repoRoot);

  cnf.dpm.cnfDir = path.join(cnfDir, cnf.dpm.cnfDir);
  cnf.dpm.cnfFile = path.join(cnfDir, cnf.dpm.cnfFile);
  cnf.dpm.src = path.resolve(cnfDir, cnf.dpm.src);
  cnf.dpm['deploy-cnf'] = path.resolve(cnfDir, cnf.dpm['deploy-cnf']);
  cnf.httpna.cnfDir = path.join(cnfDir, cnf.httpna.cnfDir);

  return cnf;
};

const run = async () => {
  const cnf = await getVespertilioConf();

  await syncBaseProjects(cnf);
  await copyProjects(cnf);
  await deployDpmHelp(cnf);
};

const updateRepo = async(gitAddr, repoRoot, targetDir) => {
  const repoDir = path.resolve(repoRoot, targetDir);
  if(! await existsDir(repoDir)) {
    await spawnp('git', ['clone', gitAddr, repoDir]);
  } else {
    await spawnp('git', ['pull'], {
      cwd: repoDir
    });
  }
};

// copy stage dir and empty Makefile
const copyStageToDpmSrcRepo = async (repoRoot, srcRepo, targetDir) => {
  const srcStage = path.resolve(srcRepo, targetDir, 'stage');
  const repoStage = path.resolve(repoRoot, targetDir, 'stage');

  await copyDir(repoStage, srcStage);
  await spawnp('cp', [path.join(__dirname, '../res/makefile'), path.resolve(srcRepo, targetDir, 'makefile')]);
};

const copyDir = async (srcDir, tarDir) => {
  await mkdirp(tarDir);
  await del([tarDir]);
  await spawnp('cp', ['-r', srcDir, tarDir]);
};

run();
